import base64
from Crypto.Util.number import long_to_bytes
from functools import reduce
from Crypto.Cipher import AES

encrypted_data = "lp93nMun3jKHRGUdfFIE0FMjnpq1syi7mlsuKyrzdLU/VULK8xGwrOscR1ukWQ7qaPSmDbJxxSQ9qZYRoeFBOw=="
initialization_vector = b'5198150478125002'
ciphertext_values = [
    701912236838003059218240709609639695702845943525803864027728188778875846171591219905642645609400939168654021522182691863655497153473574271210210286787294044877813374481013687163804558024459462649422744728198916139028397500637178375,
    701912236838003059218240709609639695702845943525803864027728188778875846171591219905642645609400939168654021522182691863655497153473574271210210286787294044877813374481013687163804558024459462649422744728198916139028397500637178375,
    701912236838003059218240709609639695702845943525803864027728188778875846171591219905642645609400939168654021522182691863655497153473574271210210286787294044877813374481013687163804558024459462649422744728198916139028397500637178375
]

key_pairs = [
    (3, 86425533438192543078915925223778492057376911833773659541049545083461842994430949090959790410902240117592889245311230009889871649401874605165267306849866372592683190819306454914289828911998054019202711614017525955521685275181584424046712863463349754310201176488258705406245569225338276925301227099609441918227),
    (3, 133539324056384270170786860294301833124695744581416861505503710009128908561235758846123429453349820021781394412347372726685425482828585135631482452685535416512894633259209230360369726490360446499233268290032246769566155223950114606228338061926430829486047206999573380471301245937467908785814148472859169963057),
    (3, 87666324472809590045695324382283318087606704560372060453544166497754867058514996701765403730277195500117138250863429026560166339334025450229695402688310834451447319749758945635154711626784494606100913099300842601764748780282315585516465994052429305595138199842617849350513913168493970132937101796544310044991)
]

def chinese_remainder(moduli, remainders):
    total = 0
    product = reduce(lambda a, b: a * b, moduli)
    for modulus, remainder in zip(moduli, remainders):
        partial_product = product // modulus
        total += remainder * pow(partial_product, -1, modulus) * partial_product
    return total % product

moduli_values = [n for _, n in key_pairs]
crt_output = chinese_remainder(moduli_values, ciphertext_values)

def cube_root_estimate(value):
    low, high = 0, value
    while low < high:
        middle = (low + high) // 2
        if middle ** 3 < value:
            low = middle + 1
        else:
            high = middle
    return low

cube_root_value = cube_root_estimate(crt_output)

if cube_root_value ** 3 != crt_output:
    raise ValueError("Exact cube root not found!")

aes_key = long_to_bytes(cube_root_value)

def decrypt_with_aes(enc_data, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted_bytes = cipher.decrypt(base64.b64decode(enc_data))
    return decrypted_bytes.decode('utf-8', errors='ignore')

try:
    decrypted_flag = decrypt_with_aes(encrypted_data, aes_key, initialization_vector)
    print(f"Decrypted Flag: {decrypted_flag}")
except Exception as e:
    print(f"Decryption error: {e}")
